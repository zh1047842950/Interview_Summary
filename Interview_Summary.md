# Interview_Summary


function test (a, b) {
    alert(b)
    return {
      test: function (c) {
        return test(c, a)
      }
    }
  }

  const webPackConfigs = {
    entry:'',
    output:{},
    mode:'',
    plugins:[],
    module:{},
    resolve:[]
  }
  
  BFC
  在正常的文档流中，块级元素是按照从上自下，内联元素从左到右的顺序排列的。
  BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
    BFC作用：
        使 BFC 内部的浮动元素不会到处乱跑。
        和浮动元素产生边界即避免margin重叠
  元素添加如下属性就可以触发BFC。
      -float属性不为none
      -position为absolute或fixed
      -display为inline-block, table-cell, table-caption, flex, inline-flex、flow-root
      -overflow不为visible。   
  VUE REACT 与传统开发的区别
    相似之处
        Virtual DOM,是一个映射真实DOM的JavaScript对象，是基于这么一个概念：改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多。
        组件化,将你的应用分拆成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。
        Props在组件中是一个特殊的属性，允许父组件往子组件传送数据。
        构建工具\Chrome 开发工具\配套框架            
    主要区别
        模板 vs JSX
        Vue鼓励你去写近似常规HTML的模板。写起来很接近标准HTML元素，只是多了一些属性。
        React推荐你所有的模板通用JavaScript的语法扩展——JSX书写
            Vue的模板语法去除了往视图/组件中添加逻辑的诱惑，保持了关注点分离。
            React/JSX乍看之下，觉得非常啰嗦，但使用JavaScript而不是模板来开发，赋予了开发者许多编程能力。
            JSX只是JavaScript混合着XML语法，然而一旦你掌握了它，它使用起来会让你感到畅快。
        状态管理 vs 对象属性
            react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流，推崇结合immutable来实现数据不可变。
            vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。
            总之，react的性能优化需要手动去做，而vue的性能优化是自动的，
        类式的组件写法，还是声明式的写法  
            react是类式的写法，api很少，而vue是声明式的写法，通过传入各种options，api和参数都很多。所以react结合typescript更容易一起写，vue稍微复杂。      
  跨域处理
  let s  ='<div class="" data-field="key"></div>'
  用正则表达式将"key"替换为"javascript"
    s.replace(/data-field=\".*\"/g,'data-field="javascript"')
    * 
* 深拷贝
* function stringifyRep(key, value) {
  if (typeof value === "function") {
    return `${value}`;
  }
  return value;
}
function parseRep(key, value) {
  return eval(value);
}
var a = {
  b: () => 1 + 1
}
var aa = JSON.parse(JSON.stringify(a, stringifyRep), parseRep)
* */


// 对WEB标准的理解
结构：html
表现：css
行为：js（dom + es）
    WEB标准（结构、表现、行为分离）有哪些优点呢?
易于维护：只需更改CSS文件，就可以改变整站的样式
页面响应快：HTML文档体积变小，响应时间短
可访问性：语义化的HTML（结构和表现相分离的HTML）编写的网页文件，更容易被屏幕阅读器识别
设备兼容性：不同的样式表可以让网页在不同的设备上呈现不同的样式
搜索引擎：语义化的HTML能更容易被搜索引擎解析，提升排名

// Web 安全的理解
    前端：
        CSRF(Cross-site request forgery), 
        中文名称：跨站请求伪造，也被称为：one click attack/session riding， 缩写为：CSRF/XSRF
        要完成一次 CSRF 攻击，受害者必须完成：
            登录受信任网站，并在本地生成 cookie
            在不登出 A 的情况下，访问危险网站 B
        CSRF 防御
            关键操作只接受 POST 请求
            验证码：
            检测 Referer：
            Token：目前主流的做法是使用 Token 防御 CSRF 攻击
                Token 要足够随机，使攻击者无法准确预测
                Token 是一次性的，即每次请求成功后要更新 Token，增加预测难度
                Token 要主要保密性，敏感操作使用 POST，防止 Token 出现在 URL 中
            过滤用户输入的内容不能阻挡 CSRF 攻击，我们需要做的事过滤请求的来源，因为有些请求是合法，有些是非法的，
            所以 CSRF 防御主要是过滤那些非法伪造的请求来源。
        XSS 攻击：
            XSS 又称为 CSS，全程为 Cross-site script，跨站脚本攻击，
                其原理是攻击者向有 XSS 漏洞的网站中输入恶意的 HTML 代码，当其它用户浏览该网站时候，
                该段 HTML 代码会自动执行，从而达到攻击的目的，如盗取用户的 Cookie，破坏页面结构，重定向到其它网站等。
             持久型 XSS 和非持久性 XSS
             持久型 XSS 就是对客户端攻击的脚本植入到服务器上，从而导致每个正常访问到的用户都会遭到这段 XSS 脚本的攻击。(如上述的留言评论功能)
             非持久型 XSS 是对一个页面的 URL 中的某个参数做文章，把精心构造好的恶意脚本包装在 URL 参数重
             再将这个 URL 发布到网上，骗取用户访问，从而进行攻击
            防御 XSS 攻击最简单直接的方法就是过滤用户的输入。
                不需要用户输入 HTML：可以直接对用户的输入进行 HTML 转义
                需要用户输入 HTML 代码时：
                    将用户的输入使用 HTML 解析库进行解析，获取其中的数据。
                    然后根据用户原有的标签属性，重新构建 HTML 元素树。
                    构建的过程中，所有的标签、属性都只从白名单中拿取。
    后端：     
        SQL 注入：
            通过把 SQL 命令插入到 Web 表单提交或页面请求的查询字符串，最终达到棋牌呢服务器执行恶意的 SQL 命令
            防护：
            1.永远不要信任用户的输入: 对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双"-"进行转换等。
            2.永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。
            3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
            4.不要把机密信息直接存放，加密或者 hash 掉密码和敏感的信息。
        DDOS 攻击：    
            分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，
            对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。
            利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。
            通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。 
            具体有几种形式：
                通过使网络过载来干扰甚至阻断正常的网络通讯；
                通过向服务器提交大量请求，使服务器超负荷；
                阻断某一用户访问服务器；
                阻断某服务与特定系统或个人的通讯。
        SYN 攻击：
            属于 DDOS 攻击中的一种具体表现形式。
            在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。
            此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.
            SYN 攻击指的是，
                攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。
            检测 SYN 攻击：
                检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。
            SYN 攻击防护：
                缩短超时（SYN Timeout）时间
                增加最大半连接数
                过滤网关防护   

TCP 
    字段	含义
    URG	紧急指针是否有效。为1，表示某一位需要被优先处理
    ACK	确认号是否有效，一般置为1。
    PSH	提示接收端应用程序立即从TCP缓冲区把数据读走。
    RST	对方要求重新建立连接，复位。
    SYN	请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1
    FIN 希望断开连接。
三次握手
    2.原理：
    1）发送端首先发送一个带有SYN（synchronize）标志地数据包给接收方。
    2）接收方接收后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了。
    3）最后，发送方再回传一个带有ACK标志的数据包，代表我知道了，表示’握手‘结束。
    通俗的说法
    1）Client：嘿，李四，是我，听到了吗？
    2）Server：我听到了，你能听到我的吗?
    3）Client：好的，我们互相都能听到对方的话，我们的通信可以开始了。
四次挥手（Four-Way-Wavehand）
    1.意义：当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。
    但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,
    它可能还需要发送一些数据给主动方后，再发送FIN报文给主动方，
    告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。
    2.原理：
    1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
    2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
    3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
    4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手
    通俗的说法
    1）Client：我所有东西都说完了
    2）Server：我已经全部听到了，但是等等我，我还没说完
    3）Server：好了，我已经说完了
    4）Client：好的，那我们的通信结束l
浏览器缓存策略
    浏览器的缓存规则是在 http 协议头和 html 页面的 meta 标签中定义的。
    主要分为两部分：强缓存和协商缓存。
        强缓存是指缓存的副本在有效期内，浏览器直接获取这个副本并渲染。
            http 协议报头有：Expires，cache-control。
            过程：浏览器发起 http 请求，浏览器缓存中查找该请求的结果以及缓存标识，
            缓存副本在有效期内，该请求返回状态码 200，从 disk cache 或 memory cache中返回。
            如果缓存副本并不在有效期内，浏览器将发起 http 请求到服务端，服务端返回请求结果和缓存规则，
            并将请求结果和缓存标识存在浏览器缓存中。
        协商缓存是在强缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。
            http 协议报头有：Last-Modified 和 ETag
            过程：浏览器发起 http 请求，浏览器缓存返回缓存标识（请求的缓存结果失效），
            浏览器携带该资源的缓存标识，向服务器发起 http 请求，如果服务器返回 304 和 not modified，
            浏览器向浏览器缓存获取该请求的缓存结果，浏览器环迅返回该请求结果。
            如果服务器返回 200 和请求结果（该资源更新了，重新返回请求结果），
            浏览器将该请求结果和缓存标识存入浏览器缓存中。
移动端300ms延迟
    主要原因:双击缩放(double tap to zoom),由于用户可以进行双击缩放或者单击跳转的操作，
    当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。
    因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕
    解决方案
         faskclick
            原理: 在检测到touchend事件的时候，会通过DOM自定义事件立即出发模拟一个click事件，并把浏览器在300ms之后真正的click事件阻止掉
            缺点: 脚本相对较大, 不建议使用
         禁用游览器缩放
            <meta name="viewport" content="user-scalable=no">
            <meta name="viewport" content="initial-scale=1, maximum-scale=1">
         更改默认的视口宽度
            <meta name="viewport" content="width=device-width">
            
touchstart去代替click事件有两个不好的地方 
    touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果
    使用touchstart事件在某些场景下可能会出现点击穿透的现象
点击穿透
    页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，
    该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件
        原因 移动端浏览器，事件执行的顺序是touchstart > touchend > click ，而click事件有300ms的延迟，
        当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，
        所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。
                         
HTTPS加密原理
    简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL

Thunk 函数
    是将参数放到一个临时函数之中，再将这个临时函数传入函数体,这个临时函数就叫做 Thunk 函数。
    是"传名调用"的一种实现策略，用来替换某个表达式
Generator函数
    Generator是协程在ES6的实现，最大的特点就是可以交出函数的执行权，懂得退让。
    Generator函数，和普通函数不一样，不同之处在于执行它不会返回结果，返回的是指针对象g，这个指针g有个next方法，调用它会执行异步任务的第一步。
事件冒泡
    对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，
    如果没有定义此事件处理程序或者事件返回true，
    那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），
    或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）
    阻止事件冒泡
        第一种： event.stopPropagation(); 
        第二种： return false; 
        第三种： event.preventDefault();
数组中的forEach和map的区别
    相同点 
        都是循环遍历数组中的每一项
        匿名函数中的this都是指向window 只能遍历数组 都不会改变原数组
    区别 
        map方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值
        forEach返回的都是undefined
jQueryajax 、fetch、 axios 异同 
    JQ 是针对MVC的编程,不符合现在前端MVVM的浪潮,整个项目太大
    4）fetch没有办法原生监测请求的进度，而XHR可以
    3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费
    2）fetch默认不会带cookie，需要添加配置项 
    1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
文件断点续传
    文件断点续传是HTML5引入的新特性，HTML5的FILE api，有一个slice方法，可以将BLOB对象进行分割。
    前端通过FileList对象获取到相应的文件，按照指定的分割方式将大文件分段，然后一段一段地传给后端，
    后端再按顺序一段段将文件进行拼接
    常用的断点续传的方法有两种，一种是通过websocket接口进行文件上传，另一种是通过ajax
js处理防抖和节流
    背景：
        在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。
    函数防抖（debounce）：
        当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，
        如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
            对应场景：需要延时处理的高频事件
                “函数防抖”的关键在于，在 一个事件 发生 一定时间 之后，才执行 特定动作。
                举个栗子，坐电梯的时候，如果电梯检测到有人进来（触发事件），就会多等待 10 秒，此时如果又有人进来（10秒之内重复触发事件），那么电梯就会再多等待 10 秒。在上述例子中，电梯在检测到有人进入 10
                秒钟之后，才会关闭电梯门开始运行
                函数防抖的要点，是需要一个 setTimeout 来辅助实现，延迟运行需要执行的代码。如果方法多次触发，则把上次记录的延迟执行代码用 clearTimeout
                清掉，重新开始计时。若计时期间事件没有被重新触发，等延迟时间计时完毕，则执行目标代码。
    函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。
        对应场景：需要做耗时耗性能操作的高频事件，需要限定函数的执行频率
            “函数节流”的要点在于，即在 一定时间 之内，限制 一个动作 只 执行一次 。
            前端开发过程中，有一些事件或者函数，会被频繁地触发（短时间按内多次触发），最常见的例如，onresize，scroll，mousemove ,mousehover
            等，这些事件的触发频率很高，不做限制的话，有可能一秒之内执行几十次、几百次，如果在这些函数内部执行了其他函数，尤其是执行了操作 DOM 的函数（浏览器操作 DOM
            是很耗费性能的），那不仅会造成计算机资源的浪费，还会降低程序运行速度，甚至造成浏览器卡死、崩溃。这种问题显然是致命的。
            除此之外，重复的 ajax 调用不仅可能会造成请求数据的混乱，还会造成网络拥塞，占用服务器带宽，增加服务器压力，显然这个问题也是需要解决的。
            主要实现思路就是通过 setTimeout定时器，通过设置延时时间，在第一次调用时，创建定时器，先设定一个变量true，写入需要执行的函数。
            第二次执行这个函数时，会判断变量是否true，是则返回。当第一次的定时器执行完函数最后会设定变量为false。那么下次判断变量时则为false，函数会依次运行。目的在于在一定的时间内，保证多次函数的请求只执行最后一次调用。
    区别：
        函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，
        而函数防抖只是在最后一次事件后才触发一次函数。
JS垃圾回收机制
    JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，
    垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。
    JS中最常见的垃圾回收方式是标记清除。
    工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
    工作流程：
    垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。
    去掉环境中的变量以及被环境中的变量引用的变量的标记。
    再被加上标记的会被视为准备删除的变量。
    垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。
var、let 和 const 区别的实现原理
    一.声明过程
    var：遇到有var的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到undefined的原因由来
    function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高
    let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，
        则报错xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行的时候，才会进入初始化阶段。
        如果let的那一行是赋值操作，则初始化和赋值同时进行
    const、class都是同let一样的道理
    二.内存分配
    var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，
        如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针
    let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错
    const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。
        不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，
        但是你可以修改指针指向的对象里面的属性
    三.变量提升
    let const 和var三者其实会存在变量提升
    let只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区。
    var的创建和初始化过程都提升了，所以在赋值前访问会得到undefined
    function 的创建、初始化、赋值都被提升了
前端HTML状态码大全
    100-199 用于指定客户端应相应的某些动作。 
    200-299 用于表示请求成功。 
    300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 
    400-499 用于指出客户端的错误。 
    500-599 用于支持服务器错误。
        详细分解： 
        1xx（临时响应） 
        表示临时响应并需要请求者继续执行操作的状态代码。
        代码 说明 
        100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 
        101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。
        2xx （成功） 
        表示成功处理了请求的状态代码。
        代码 说明 
        200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 
        201 （已创建） 请求成功并且服务器创建了新的资源。 
        202 （已接受） 服务器已接受请求，但尚未处理。 
        203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 
        204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 
        205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。 
        206 （部分内容） 服务器成功处理了部分 GET 请求。
        3xx （重定向） 
        表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
        代码 说明 
        300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 
        301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 
        302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 
        303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 
        304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 
        305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 
        307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
        4xx（请求错误） 
        这些状态代码表示请求可能出错，妨碍了服务器的处理。
        代码 说明 
        400 （错误请求） 服务器不理解请求的语法。 
        401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
        403 （禁止） 服务器拒绝请求。 
        404 （未找到） 服务器找不到请求的网页。 
        405 （方法禁用） 禁用请求中指定的方法。 
        406 （不接受） 无法使用请求的内容特性响应请求的网页。 
        407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 
        408 （请求超时） 服务器等候请求时发生超时。 
        409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 
        410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 
        411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 
        412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 
        413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 
        414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 
        415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 
        416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 
        417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。
        5xx（服务器错误） 
        这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
        代码 说明 
        500 （服务器内部错误） 服务器遇到错误，无法完成请求。 
        501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 
        502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
        503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 
        504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 
        505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。
vue loader原理
    Vue Loader 是一个 webpack 的 loader，它允许你以一种名为单文件组件 SFC的格式撰写 Vue 组件
    允许为 Vue 组件的每个部分使用其它的 webpack loader，例如在 <style> 的部分使用 Sass 和在 <template> 的部分使用 Pug；
    允许在一个 .vue 文件中使用自定义块，并对其运用自定义的 loader 链；
    使用 webpack loader 将 <style> 和 <template> 中引用的资源当作模块依赖来处理；
    为每个组件模拟出 scoped CSS；
    在开发过程中使用热重载来保持状态。
vue 数据驱动视图原理
    数据驱动是通过MVVM这种框架来实现的。MVVM框架主要包含3个部分:model、view和 viewmodel。
        Model:指的是数据部分，对应到前端就是javascript对象
        View:指的是视图部分，对应前端就是dom
        Viewmodel:就是连接视图与数据的中间件
    原理:
        首先，vuejs在实例化的过程中，会对遍历传给实例化对象选项中的data 选项，
        遍历其所有属性并使用 Object.defineProperty 把这些属性全部转为 getter/setter。
        同时每一个实例对象都有一个watcher实例对象，他会在模板编译的过程中,用getter去访问data的属性，
        watcher此时就会把用到的data属性记为依赖，这样就建立了视图与数据之间的联系。
        当之后我们渲染视图的数据依赖发生改变（即数据的setter被调用）的时候，watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。
        这样就实现了所谓的数据对于视图的驱动。
            Object.defineProperty->getter/setter
es5继承
    构造函数、原型和实例的关系：每一个构造函数都有一个原型对象，每一个原型对象都有一个指向构造函数的指针，而每一个实例都包含一个指向原型对象的内部指针，
    原型链实现继承
        基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，即让原型对象等于另一个类型的实例
    借用构造函数
        基本思想：在子类型构造函数的内部调用超类型构造函数，通过使用apply()和call()方法可以在将来新创建的对象上执行构造函数
    组合继承
        基本思想：将原型链和借用构造函数技术组合到一起。使用原型链实现对原型属性和方法的继承，用借用构造函数模式实现对实例属性的继承。
        这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性   
    原型式继承
        基本思想：不用严格意义上的构造函数，借助原型可以根据已有的对象创建新对象，还不必因此创建自定义类型   
    寄生式继承
        基本思想：寄生式继承是与原型式继承紧密相关的一种思路，它创造一个仅用于封装继承过程的函数，在函数内部以某种方式增强对象，最后再返回对象。
ES6继承
    基本用法：Class之间通过使用extends关键字，这比通过修改原型链实现继承，要方便清晰很多     
    子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，
    然后对其进行加工，如果不调用super方法，子类就得不到this对象。因此，只有调用super之后，才可以使用this关键字。
vue项目首屏加载优化
    仔细考虑组件是否需要全局引入,非多处使用的模块改用手动引入
    使用更轻量级的工具库
    CDN优化
        使用 CDN 剔除这部分不经常变化的公共库。我们将vue，vue-router，vuex，axios，jquery，underscore，
        使用CDN资源引入，对应去除vue.use相关代码
    Nginx开启 gzip
    路由懒加载
        路由组件如果不按需加载的话，就会把所有的组件一次性打包到app.js中，导致首次加载内容过多
        component:(resolve)=> {require(['VIEWS/buyer/buyerSummary/index.vue'], resolve)}
        component: () => import('VIEWS/buyer/buyerSummary/index'),
webpack 构建性能优化策略
    路由懒加载
    启用gzip压缩和关闭sourcemap
    引用的库尽量按需加载,避免全部引入，加大项目体积。以cdn方式载入需要的库，也可以减少打包后的体积。
    缩小文件的搜索范围
        resolve字段告诉webpack怎么去搜索文件，所以首先要重视resolve字段的配置：
        设置resolve.modules:[path.resolve(__dirname, 'node_modules')]避免层层查找。
        设置resolve.mainFields:['main']，设置尽量少的值可以减少入口文件的搜索步骤
        对庞大的第三方模块设置resolve.alias, 使webpack直接使用库的min文件，避免库内解析
        合理配置resolve.extensions，减少文件查找
            当导入语句没带文件后缀时，Webpack会根据extensions定义的后缀列表进行文件查找，所以：
                列表值尽量少
                频率高的文件类型的后缀写在前面
                源码中的导入语句尽可能的写上文件后缀
    module.noParse字段告诉Webpack不必解析哪些文件，可以用来排除对非模块化库文件的解析        
    置loader时，通过test、exclude、include缩小搜索范围
    合理配置 CommonsChunkPlugin
        1、传入字符串参数，由chunkplugin自动计算提取
        2、有选择的提取公共代码
        3、将entry下所有的模块的公共部分（可指定引用次数）提取到一个通用的chunk中
        4、抽取enry中的一些lib抽取到vendors中
    通过 externals 配置来提取常用库
    利用 DllPlugin 和 DllReferencePlugin 预编译资源模块
        DllPlugin的作用是预先编译一些模块，而DllReferencePlugin则是把这些预先编译好的模块引用起来。
            这边需要注意的是DllPlugin必须要在DllReferencePlugin执行前先执行一次，
            dll这个概念应该也是借鉴了windows程序开发中的dll文件的设计理念。   
        dll预编译出来的模块可以作为静态资源链接库可被重复使用，尤其适合多个项目之间的资源共享，
        dll资源能有效地解决资源循环依赖的问题，
        由于externals的配置项需要对每个依赖库进行逐个定制，所以每次增加一个组件都需要手动修改，略微繁琐，
        而通过dllPlugin则能完全通过配置读取，减少维护的成本； 
    使用HappyPack开启多进程Loader转换
        将原有的webpack对loader的执行过程从单一进程的形式扩展多进程模式，原本的流程保持不变，
    使用ParallelUglifyPlugin开启多进程压缩JS文件
        uglifyJS凭借基于node开发，压缩比例高，使用方便等诸多优点已经成为了js压缩工具中的首选
        build进度走到80%前后时，会发生很长一段时间的停滞，
        经测试对比发现这一过程正是uglfiyJS在对我们的output中的bunlde部分进行压缩耗时过长导致，
        针对这块我们可以使用webpack-uglify-parallel来提升压缩速度。      
            webpack-uglify-parallel的是实现原理是采用了多核并行压缩的方式来提升我们的压缩速度。  
    使用Tree Shaking剔除JS死代码
        它依赖ES6的import、export的模块化语法。它正常工作的前提是代码必须采用ES6的模块化语法
    多页面应用提取页面间公共代码，以利用缓存    
    分割代码以按需加载    
escape() 函数
     除- _ . * @ + /  ASCII 字母和数字之外都被转义序列替换
encodeURI() 函数
    除- _ . * ! ~ ' ( ) ASCII 字母和数字之外都被转义
encodeURIComponent() 函数
    除- _ . * ! ~  ' ( ) ASCII 字母和数字之外都被编码
为什么JavaScript是单线程
    JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。
    比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准
    为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
    为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。
Vue.nextTick
    Vue 异步执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。
    如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。
    然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
任务队列
    所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。
        同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
        异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，
            只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。
    异步执行的运行机制如下:
    （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。
    （2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。
    （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
    （4）主线程不断重复上面的第三步。
        主线程在运行的时候会产生堆栈，堆就是存储变量，栈记录执行的顺序，
        如果碰到回调函数、DOM操作比如点击、鼠标移上去等、setTimeout操作会放到任务队列，
        只有栈中的代码执行完毕才会从任务队列取出代码，进行执行。
        可以这么理解，一堆代码，该放到stack里面的方法，放到stack里面，然后这堆代码里面的异步操作放到任务队列里面，
        然后执行栈里面的代码，栈里面的代码执行完毕，执行任务队列里面的代码，所以代码的执行顺序和写的顺序并不是一直的

数组去重
    1、创建新数组，利用Array.indexOf属性，遍历原有数组的元素，判断该元素是否存在新数组中，不存在则将该元素放入新数组，返回新数组即可
    2、双层循环遍历数组的元素
    3、排序后遍历比较相邻的元素
    4、利用数组 filter 方法过滤，filter中将首次出现的位置与下标相等的元素返回
        (item, index, array)=>array.indexOf(item) === index
    5、利用对象属性的唯一性,遍历数组，将数组元素作为对象的键，已存在的键
    6、利用 ES6 set 数据结构
    7、创建新数组，遍历原有数组的元素，判断元素的indexOf和lastIndexOf属性值，相等则将该元素放入新数组，返回新数组即可
    
js对象的深拷贝及其的几种方法
    1：jq使用，$.extend({},obj)
    2:Object.assign({},obj)
    3：clone(obj)
      var clone = function (obj) { return JSON.parse(JSON.stringify(obj)); }
      这种方法会忽略值为function以及undefied的字段，而且对date类型的支持也不太友好
    4、封装最好的深拷贝的方法
          var clone = function (obj) {
            if (obj === null) return null
            if (typeof obj !== 'object') return obj
            if (obj.constructor === Date) return new Date(obj)
            var newObj = new obj.constructor()  //保持继承链
            for (var key in obj) {
              if (obj.hasOwnProperty(key)) {   //不遍历其原型链上的属性
                var val = obj[key]
                newObj[key] = typeof val === 'object' ? arguments.callee(val) : val // 使用arguments.callee解除与函数名的耦合
              }
            }
            return newObj
          }    
            1、用new obj.constructor ()构造函数新建一个空的对象，而不是使用{}或者[],这样可以保持原形链的继承；
            2、用obj.hasOwnProperty(key)来判断属性是否来自原型链上，因为for..in..也会遍历其原型链上的可枚举属性。
            3、上面的函数用到递归算法，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。
                但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，需要使用 arguments.callee。

5 个 JS 不良编码习惯
    1.不要使用隐式类型转换
        使你的代码在边缘情况下不太稳定
            一个获取对象属性的函数。如果属性不存在，函数返回一个默认值
             if (!object[propertyName]) {
                return defaultValue;
              }
              属性存在的验证依赖于if（！object [propertyName]）{...}隐式转换的布尔值
    2. 不要使用早期的JavaScript技巧
        ES6 中可以使用 array.includes(item) 来代替 array.indexOf(item) !== -1
    3. 不要污染函数作用域
        变量尽量在使用到的作用域声明
    4.尽量避免 undefined 和 null     
        判断对象属性是否存在尽量用 propName in object
        null是一个缺失对象的指示符。应该尽量避免从函数返回 null，特别是使用null作为参数调用函数。         

URL和URI的区别
    URI包括URL和URN两个类别，URL是URI的子集，所以URL一定是URI，而URI不一定是URL
    URI = Universal Resource Identifier 统一资源标志符，用来标识抽象或物理资源的一个紧凑字符串。
    URL = Universal Resource Locator 统一资源定位符，一种定位资源的主要访问机制的字符串，一个标准的URL必须包括：protocol、host、port、path、parameter、anchor。
    URN = Universal Resource Name 统一资源名称，通过特定命名空间中的唯一名称或ID来标识资源。
